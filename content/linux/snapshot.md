---
title: "Snapshot"
date: 2021-04-21T17:45:03+08:00
draft: false
tags: ["linux","sre","ops","snapshot"]
categories: ["linux"]
---

# 快照

## 底层实现现有cow和row两种

## cow 写时复制 copy-on-write

创建快照后， 如果源卷数据发生了变化， 那么快照系统会首先将原始数据拷贝到快照卷上对应的数据块中， 然后再对源卷进行改写。

### 写操作

快照创建以后，若上层业务对源卷写入数据X， X在缓存中排队， 快照系统将X即将写入的位置（逻辑位置） 上的数据Y拷贝到快照卷中对应的位置（逻辑地址）， 同时，生成一张映射表， 表中一列记录源卷上数据表话的逻辑地址， 另一列记录快照卷上数据变化的逻辑地址。

> 上层业务每下发一个数据块，存储上发生了两次写操作： 一次是源卷将数据写入快照卷， 一次是上层业务将数据写入源卷

### 读操作（快照）

快照卷若映射给上层业务进行数据分析时， 针对快照进行读操作时，首先由快照系统判断，上层业务需要读取的数据是否在快照卷中， 若在直接将从快照卷读取， 若不在，则查询映射表，去对应源卷的逻辑地址中读取（这个查表并去源卷读的操作，也叫读重定向）。 

### 读操作（源卷）

针对源卷读写没有跟快照有任何数据交互， 快照可以单独作为一个可以读取的副本

### 快照回滚

源卷锁定-查映射表-数据回写-源卷解锁

首先锁定源卷，停止io写入，接着查询映射表中的逻辑地址，根据地址，将地址对应的数据，从快照中读回到源卷， 写完后源卷解锁恢复可用状态

### 快照删除

采用cow技术的快照，其源卷即保存着完整的实时数据，因此，删除快照时直接销毁了快照卷和映射表，与源卷不存在数据交互。

## row 写时重定向 rediret-on-write

创建快照以后，快照系统把对数据卷的写请求重定向给了快照预留的存储空间，直接将新的数据写入快照卷， 上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读

### 写操作

快照创建后，若上层业务对源卷写数据X，X在缓存中排队，快照系统判断X即将写入源卷的逻辑地址，然后将数据X写入快照卷中预留的对应逻辑地址中，同时将源和快照的逻辑地址写入映射表， 即写重定向。

上层针对源卷写入一个数据块X，存储上只发生了一次写操作，只是写之前进行了重定向

### 读操作（源卷）

若快照创建后，上层业务对源卷进行读，则有两种情况： 1. 若读取的数据在创建快照前产生，数据是保存在源卷上的，那么上层就从源卷进行读取；2. 若需要读取的数据是创建快照以后产生的，那么上层就查询映射表，从快照卷进行读取（即读重定向）

### 读操作（快照卷）

两种情况： 1. 若读取的数据在创建快照前产生， 数据是保存在源卷上的，那么上层就查询映射表，从源卷进行读取。 2. 若需要读取的数据是创建快照后才产生的，那么上层就直接从快照卷进行读取

### 快照回滚

row产生的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中，因此，快照的回滚只是取消了对源卷的读重定向操作，通俗的说，就是源卷上没有进行任何数据操作， 上层业务对源卷的读，仅限于读源卷（即不会去读取快照卷的数据）

### 快照删除

其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入到了快照中，因此，若要删除快照，必然要先将快照卷中的数据，回拷到源卷中，拷贝完成才能删除，

此时我们设想，如果针对一份源数据，在18：00 创建了快照，上层业务持续禅城了大量新的数据，19：00又创建了快照，20：00 又创建了快照，那么在有多份快照的情况下如果需要删除快照，就会出现多个快照向源卷回拷数据的情况，可能导致回拷量非常大，耗时长

# 快照

## 底层实现现有cow和row两种

## cow 写时复制 copy-on-write

创建快照后， 如果源卷数据发生了变化， 那么快照系统会首先将原始数据拷贝到快照卷上对应的数据块中， 然后再对源卷进行改写。

### 写操作

快照创建以后，若上层业务对源卷写入数据X， X在缓存中排队， 快照系统将X即将写入的位置（逻辑位置） 上的数据Y拷贝到快照卷中对应的位置（逻辑地址）， 同时，生成一张映射表， 表中一列记录源卷上数据表话的逻辑地址， 另一列记录快照卷上数据变化的逻辑地址。

> 上层业务每下发一个数据块，存储上发生了两次写操作： 一次是源卷将数据写入快照卷， 一次是上层业务将数据写入源卷

### 读操作（快照）

快照卷若映射给上层业务进行数据分析时， 针对快照进行读操作时，首先由快照系统判断，上层业务需要读取的数据是否在快照卷中， 若在直接将从快照卷读取， 若不在，则查询映射表，去对应源卷的逻辑地址中读取（这个查表并去源卷读的操作，也叫读重定向）。 

### 读操作（源卷）

针对源卷读写没有跟快照有任何数据交互， 快照可以单独作为一个可以读取的副本

### 快照回滚

源卷锁定-查映射表-数据回写-源卷解锁

首先锁定源卷，停止io写入，接着查询映射表中的逻辑地址，根据地址，将地址对应的数据，从快照中读回到源卷， 写完后源卷解锁恢复可用状态

### 快照删除

采用cow技术的快照，其源卷即保存着完整的实时数据，因此，删除快照时直接销毁了快照卷和映射表，与源卷不存在数据交互。

## row 写时重定向 rediret-on-write

创建快照以后，快照系统把对数据卷的写请求重定向给了快照预留的存储空间，直接将新的数据写入快照卷， 上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读

### 写操作

快照创建后，若上层业务对源卷写数据X，X在缓存中排队，快照系统判断X即将写入源卷的逻辑地址，然后将数据X写入快照卷中预留的对应逻辑地址中，同时将源和快照的逻辑地址写入映射表， 即写重定向。

上层针对源卷写入一个数据块X，存储上只发生了一次写操作，只是写之前进行了重定向

### 读操作（源卷）

若快照创建后，上层业务对源卷进行读，则有两种情况： 1. 若读取的数据在创建快照前产生，数据是保存在源卷上的，那么上层就从源卷进行读取；2. 若需要读取的数据是创建快照以后产生的，那么上层就查询映射表，从快照卷进行读取（即读重定向）

### 读操作（快照卷）

两种情况： 1. 若读取的数据在创建快照前产生， 数据是保存在源卷上的，那么上层就查询映射表，从源卷进行读取。 2. 若需要读取的数据是创建快照后才产生的，那么上层就直接从快照卷进行读取

### 快照回滚

row产生的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中，因此，快照的回滚只是取消了对源卷的读重定向操作，通俗的说，就是源卷上没有进行任何数据操作， 上层业务对源卷的读，仅限于读源卷（即不会去读取快照卷的数据）

### 快照删除

其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入到了快照中，因此，若要删除快照，必然要先将快照卷中的数据，回拷到源卷中，拷贝完成才能删除，

此时我们设想，如果针对一份源数据，在18：00 创建了快照，上层业务持续禅城了大量新的数据，19：00又创建了快照，20：00 又创建了快照，那么在有多份快照的情况下如果需要删除快照，就会出现多个快照向源卷回拷数据的情况，可能导致回拷量非常大，耗时长
